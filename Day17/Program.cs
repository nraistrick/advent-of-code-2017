using System;
using System.Collections.Generic;

namespace Day17
{
    /// <summary>
    /// Calculates the values generated by a spinlock in a circular buffer
    /// </summary>
    public static class Program
    {
        private static void Main()
        {
            var circularBuffer = new List<int> {0};
            var finalIndex = RunSpinlock(circularBuffer, 2017, 303);
            Console.WriteLine($"The value generated after 2017 is: {circularBuffer[finalIndex + 1]}");

            var valueAfterZero = GetSpinlockValueAfterZero(50000000, 303);
            Console.WriteLine($"The value inserted after zero is: {valueAfterZero}");
        }

        /// <summary>
        /// Generates all the values from a spinlock for a given number of cycles
        /// </summary>
        /// <param name="circularBuffer">The buffer to populate with values</param>
        /// <param name="iterations">The number of values to generate</param>
        /// <param name="steps">The number of steps to move forward after each generated value</param>
        /// <returns>The index of the final generated value</returns>
        public static int RunSpinlock(List<int> circularBuffer, int iterations, int steps)
        {
            var index = 0;

            for (var i = 1; i <= iterations; i++)
            {
                for (var j = 0; j < steps; j++)
                {
                    index = (index + 1) % circularBuffer.Count;
                }

                circularBuffer.Insert(index + 1, i);

                index++;
            }

            return index;
        }

        /// <summary>
        /// Gets the value that appears after zero for a given number of spinlock iterations
        /// </summary>
        /// <param name="iterations"></param>
        /// <param name="steps"></param>
        /// <returns></returns>
        public static int GetSpinlockValueAfterZero(int iterations, int steps)
        {
            var index = 0;
            var valueAfterZero = 0;

            for (var i = 1; i <= iterations; i++)
            {
                index = (index + steps) % Math.Max(i, 1);
                if (index == 0)
                {
                    valueAfterZero = i;
                }

                index++;
            }

            return valueAfterZero;
        }
    }
}